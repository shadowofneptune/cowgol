include "cowgol.coh";
include "tests/_framework.coh";

sub doloop(x: intptr, y: intptr): (r: intptr) goto is
	if x > 0 then
		goto doloop(x - y, y);
	else
		r := x;
	end if;
end sub;

print("simple-tailrec");
if doloop(10, 1) == 0 then yes(); else no(); end if;

print("does-not-smash-stack"); #should run to completion and not crash.
if doloop(0xFFFF, 1) == 0 then yes(); end if;

@decl sub mutual2(x: intptr): (r: intptr) goto;

sub mutual1(x: intptr): (r: intptr) goto is
	if x < 60 then
		goto mutual2(x + 10);
	else
		r := x;
	end if;
end sub;

@impl sub mutual2 is
	if x < 60 then
		goto mutual1(x + 5);
	else
		r := x;
	end if;
end sub;

print("mutual-tailrec");
if mutual1(0) == 60 then yes(); else no(); end if;

sub nested1(): (r: intptr) is
	r := mutual1(0);
end sub;

sub nested2(x: intptr): (r: intptr) goto is
	x := x + nested1();
	if x < 240 then
		goto nested2(x);
	else
		r := x;
	end if;
end sub;

print("nested-tailrec");
if nested2(0) == 240 then yes(); else no(); end if;

interface indirect(x: intptr, offset: intptr): (r: intptr) goto;
var ind_ptr: [indirect];

sub indirect1 implements indirect is
	if x != 50 then
		var y := offset % (@bytesof ind_ptr * 4);
		goto [ind_ptr + y](x + 5, offset + 1);
	else
		r := x;
	end if;
end sub;

sub indirect2 implements indirect is
	if x != 50 then
		var y := (offset % 4) * @bytesof ind_ptr;
		goto [ind_ptr + y](x + 5, offset + 1);
	else
		r := x;
	end if;
end sub;

sub indirect3 implements indirect is
	if x != 50 then
		var y := (offset % 4) * @bytesof ind_ptr;
		goto [ind_ptr + y](x + 5, offset + 1);
	else
		r := x;
	end if;
end sub;

sub indirect4 implements indirect is
	if x != 50 then
		var y := (offset % 4) * @bytesof ind_ptr;
		goto [ind_ptr + y](x + 5, offset + 1);
	else
		r := x;
	end if;
end sub;

var ind: indirect[] := {indirect1, indirect2, indirect3, indirect4};
ind_ptr := &ind[0];
print("indirect-tailrec");
if [ind_ptr](0, 0) == 50 then yes(); else no(); end if;
